#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Mar 14 14:28:59 2025

@author: brennan
"""

import torch
import numpy as np

from .monitor import Monitor
from torch.utils.data import TensorDataset, DataLoader
from torch.utils.data.dataloader import default_collate
from ..analysis import displacement_power_spectrum


class UpscaleMonitor(Monitor):
    """A monitor class for tracking the uniform metric, or Chebyshev distance,
    between the power spectra of real high resolution data and fake super
    resolution data created by the generator.
    
    This monitor also saves a checkpoint for the best value for the uniform 
    metric found during training.
    """
    
    def __init__(
            self, 
            gan, 
            realisations, 
            device,
            checkpoint_dir
        ):
        self.gan = gan
        self.generator = gan.generator
        self.realisations = realisations
        self.device = device
        self.checkpoint_dir = checkpoint_dir
        
        self.current_best_uniform_metric = float('inf')
        self.uniform_metric_history = []
        self.current_best_l2_metric = float('inf')
        self.l2_metric_history = []
    
        
    def set_data_set(
            self, 
            lr_data, 
            hr_data,
            particle_mass, 
            box_size, 
            grid_size,
            styles = None
        ):
        """
        Creates a dataset consiting of samples of lr particle displacements,
        the power spectrum of the corresponding hr particle displacments and
        optional style parameters.
        
        This is used for computing both the uniform metric and l2 metric 
        between the power spectra of hr and sr data.
        
        The dataset is composed with a dataloader object which is stored as a
        `data` attribute.
        """
        # Set basic parameters.
        self.mass        = particle_mass
        self.box_size    = box_size
        self.grid_size   = grid_size
        self.num_samples = lr_data.shape[0]
        
        # Compute the high-resolution spectra.
        hr_spectra = self.get_spectra(hr_data)
        device = self.device
        
        # Create the appropriate TensorDataset based on whether style data is 
        # provided.
        if styles is None:
            dataset = TensorDataset(lr_data, hr_spectra)
        else:
            dataset = TensorDataset(lr_data, hr_spectra, styles)
         
        # Create a collate function to move data to the device and return a
        # defualt style variable (None).
        def collate(batch):
            batch = list(zip(*batch))
            lr_sample  = default_collate(batch[0]).to(device)
            hr_spectra = default_collate(batch[1]).to(device)
            style = (
                None if styles is None 
                else default_collate(batch[2]).to(device)
            )
            return lr_sample, hr_spectra, style
            
        self.data = DataLoader(dataset, collate_fn=collate)
        
        
    def get_spectra(self, displacements):
        """Return a tensor containing the power spectra of the given 
        displacement data.
        """
        spectra = []
        for sample in displacements:
            sample = sample[None, 0:3, ...]
            spectrum = displacement_power_spectrum(
                sample, self.mass, self.box_size, self.grid_size
            )
            spectra.append(spectrum[1])
        
        return torch.stack(spectra)
    
    
    def post_epoch_processing(self, epoch):
        """Compute the uniform metric between the power spectra of real high
        resolution data and fake super resolution data generated by the current
        model.
        """
        uniform_metric = 0
        l2_metric = 0
        
        for lr_sample, hr_spectrum, style in self.data:
            # Generate fake super resolution data with the current generator.
            z = self.generator.sample_latent_space(1, self.device)
            sr_sample = self.generator(lr_sample, z, style)
            sr_sample = sr_sample.detach()
            
            # Get the power spectrum of the fake data.
            sr_sample = sr_sample[:, 0:3, ...]
            sr_ks, sr_spectrum, sr_uncertainty = displacement_power_spectrum(
                sr_sample, self.mass, self.box_size, self.grid_size
            )
            
            # Compute the uniform metric between the real and fake power 
            # spectrum.
            metric = self.uniform_metric(sr_spectrum, hr_spectrum)
            uniform_metric = max(uniform_metric, metric.item())
            
            # Compute the L2 metric between the real and fake spectra.
            metric = self.l2_metric(sr_spectrum, hr_spectrum, sr_ks)
            l2_metric += metric.item()
        
        l2_metric /= self.num_samples
        
        # Save the new metric values.
        self.uniform_metric_history.append(uniform_metric)
        self.l2_metric_history.append(l2_metric)
        filename = self.checkpoint_dir + 'power_spectra_metrics.npz'
        np.savez(filename, **{
            'uniform_metric' : self.uniform_metric_history,
            'l2_metric' : self.l2_metric_history
        })
        
        # If the current metric is better than the best one found so far then
        # replace the best checkpoint with a checkpoint of the current model.
        if uniform_metric < self.current_best_uniform_metric:
            self.current_best_uniform_metric = uniform_metric
            
            print(f"[Current best uniform metric {uniform_metric:.4f}]")
            checkpoint_name = 'best_uniform_model'
            checkpoint_name += f'_epoch={epoch}'
            checkpoint_name += f'_{uniform_metric:.4f}/'
            self.gan.save(self.checkpoint_dir + checkpoint_name)
            
        if l2_metric < self.current_best_l2_metric:
            self.current_best_l2_metric = l2_metric
            
            print(f"[Current best l2 metric {l2_metric:.4f}]")
            checkpoint_name = 'best_l2_model'
            checkpoint_name += f'_epoch={epoch}'
            checkpoint_name += f'_{l2_metric:.4f}/'
            self.gan.save(self.checkpoint_dir + checkpoint_name)
    
        
    def uniform_metric(self, spectrum_a, spectrum_b):
        return torch.max(torch.abs(spectrum_a - spectrum_b))
    
    
    def l2_metric(self, spectrum_a, spectrum_b, ks):
        return torch.trapezoid((spectrum_a - spectrum_b) ** 2, ks)**0.5