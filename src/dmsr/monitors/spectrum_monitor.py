#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Mar 14 14:28:59 2025

@author: brennan
"""

import torch
import numpy as np

from .monitor import Monitor
from torch.utils.data import DataLoader
from torch.utils.data.dataloader import default_collate

from ..field_analysis import cic_density_field, power_spectrum


class SpectrumMonitor(Monitor):
    """A monitor class for tracking the uniform metric, or Chebyshev distance,
    between the power spectra of real high resolution data and fake super
    resolution data created by the generator.
    
    This monitor also saves a checkpoint for the best value for the uniform 
    metric found during training.
    """
    
    def __init__(
            self, 
            gan,
            dataset,
            box_size,
            grid_size,
            particle_mass,
            summary_stats,
            device,
            checkpoint_dir
        ):
        self.gan = gan
        self.generator = gan.generator
        self.box_size = box_size
        self.grid_size = grid_size
        self.particle_mass = particle_mass
        self.summary_stats = summary_stats
        self.num_samples = len(dataset)
        self.device = device
        self.checkpoint_dir = checkpoint_dir
        
        # Create a collate function to move data to the device and return a
        # default style variable (None).
        def collate(batch):
            batch = list(zip(*batch))
            lr_sample  = default_collate(batch[0]).to(device)
            hr_spectra = default_collate(batch[1]).to(device)
            style = (
                None if batch[2][0] is None 
                else default_collate(batch[2]).to(device)
            )
            return lr_sample, hr_spectra, style
        
        self.data = DataLoader(
            dataset, 
            batch_size=1, 
            # num_workers=1, 
            # prefetch_factor=8, 
            collate_fn=collate
        )
        
        self.current_best_uniform_metric = float('inf')
        self.uniform_metric_history = []
        self.current_best_l2_metric = float('inf')
        self.l2_metric_history = []
        
    
    
    def post_epoch_processing(self, epoch):
        """Compute the uniform metric between the power spectra of real high
        resolution data and fake super resolution data generated by the current
        model.
        """
        uniform_metric = 0
        l2_metric = 0
        
        for lr_sample, hr_spectrum, style in self.data:
            # Generate fake data and get its power spectrum.
            z = self.generator.sample_latent_space(1, self.device)
            sr_sample = self.generator(lr_sample, z, style)
            displacements = sr_sample[:, 0:3, ...].detach()
            displacements *= self.summary_stats['HR_disp_fields_std']
            sr_ks, sr_spectrum = self.get_power_spectrum(displacements)
            
            # Compute the uniform metric between the real and fake power 
            # spectrum.
            metric = self.uniform_metric(sr_spectrum, hr_spectrum)
            uniform_metric = max(uniform_metric, metric.item())
            
            # Compute the L2 metric between the real and fake spectra.
            metric = self.l2_metric(sr_spectrum, hr_spectrum, sr_ks)
            l2_metric += metric.item()
        
        l2_metric /= self.num_samples
        
        # Save the new metric values.
        self.uniform_metric_history.append(uniform_metric)
        self.l2_metric_history.append(l2_metric)
        filename = self.checkpoint_dir / 'power_spectra_metrics.npz'
        np.savez(filename, **{
            'uniform_metric' : self.uniform_metric_history,
            'l2_metric' : self.l2_metric_history
        })
        
        # If the current metric is better than the best one found so far then
        # replace the best checkpoint with a checkpoint of the current model.
        if uniform_metric < self.current_best_uniform_metric:
            self.current_best_uniform_metric = uniform_metric
            
            print(f"[Current best uniform metric {uniform_metric:.4f}]")
            checkpoint_name = 'best_uniform_model'
            checkpoint_name += f'_epoch={epoch}'
            checkpoint_name += f'_{uniform_metric:.4f}/'
            self.gan.save(self.checkpoint_dir / checkpoint_name)
            
        if l2_metric < self.current_best_l2_metric:
            self.current_best_l2_metric = l2_metric
            
            print(f"[Current best l2 metric {l2_metric:.4f}]")
            checkpoint_name = 'best_l2_model'
            checkpoint_name += f'_epoch={epoch}'
            checkpoint_name += f'_{l2_metric:.4f}/'
            self.gan.save(self.checkpoint_dir / checkpoint_name)
    
    
    def get_power_spectrum(self, field):
        box_size = self.box_size
        grid_size = self.grid_size
        mass = self.particle_mass
        density = cic_density_field(field, box_size, grid_size)[0, 0, ...]
        density *= mass
        sr_ks, sr_spectrum, _ = power_spectrum(density, box_size, grid_size)
        return sr_ks, sr_spectrum
    
        
    def uniform_metric(self, spectrum_a, spectrum_b):
        return torch.max(torch.abs(spectrum_a - spectrum_b))
    
    
    def l2_metric(self, spectrum_a, spectrum_b, ks):
        return torch.trapezoid((spectrum_a - spectrum_b) ** 2, ks)**0.5